# 二叉树实现 (Binary Tree)

二叉树是每个节点最多有两个子节点的树形数据结构。

## 🔧 功能特性

- **普通二叉树**：层序插入的二叉树
- **二叉搜索树**：保持有序性的二叉树
- **遍历算法**：前序、中序、后序、层序遍历
- **树操作**：插入、删除、查找、计算高度
- **树应用**：平衡性检查、最近公共祖先

## 💻 核心方法

### 普通二叉树
```python
bt = BinaryTree()
bt.insert(val)              # 层序插入
bt.preorder()               # 前序遍历（根-左-右）
bt.inorder()                # 中序遍历（左-根-右）
bt.postorder()              # 后序遍历（左-右-根）
bt.level_order()            # 层序遍历
bt.height()                 # 计算高度
bt.count_nodes()            # 节点数量
bt.find(val)                # 查找节点
bt.find_path(val)           # 查找路径
```

### 二叉搜索树
```python
bst = BinarySearchTree()
bst.insert(val)             # 有序插入
bst.search(val)             # 搜索节点
bst.delete(val)             # 删除节点
bst.find_min()              # 最小值
bst.find_max()              # 最大值
bst.inorder()               # 有序遍历
bst.is_valid_bst()          # 验证BST
```

### 树应用
```python
# 最近公共祖先
TreeApplications.lowest_common_ancestor(root, p, q)

# 平衡性检查
TreeApplications.is_balanced(node)
```

## 📈 时间复杂度

| 操作 | 普通二叉树 | 二叉搜索树(平衡) | 二叉搜索树(最坏) |
|------|------------|------------------|------------------|
| 搜索 | O(n) | O(log n) | O(n) |
| 插入 | O(n) | O(log n) | O(n) |
| 删除 | O(n) | O(log n) | O(n) |
| 遍历 | O(n) | O(n) | O(n) |

## 🎯 运行示例

```bash
$ python binary_tree.py

=== 二叉树演示 ===
1. 插入节点:
   插入 [1, 2, 3, 4, 5, 6, 7]

2. 遍历操作:
   前序遍历: [1, 2, 4, 5, 3, 6, 7]
   中序遍历: [4, 2, 5, 1, 6, 3, 7]
   后序遍历: [4, 5, 2, 6, 7, 3, 1]
   层序遍历: [1, 2, 3, 4, 5, 6, 7]

3. 树的属性:
   高度: 3
   节点数: 7

4. 查找操作:
   查找 5: True
   路径: [1, 2, 5]

=== 二叉搜索树演示 ===
1. 插入节点:
   插入 [50, 30, 70, 20, 40, 60, 80]

2. 中序遍历（有序）: [20, 30, 40, 50, 60, 70, 80]

3. 搜索操作:
   搜索 40: 找到

4. 最值查找:
   最小值: 20
   最大值: 80

5. 验证BST: True

6. 删除节点:
   删除前: [20, 30, 40, 50, 60, 70, 80]
   删除30后: [20, 40, 50, 60, 70, 80]

=== 树的应用演示 ===
1. 构建测试树:

2. 平衡性检查:
   树是否平衡: True
```

## 🎓 学习要点

### 二叉树的特性
- **层次结构**：具有明确的层级关系
- **递归性质**：子树也是二叉树
- **有序性**：二叉搜索树保持左小右大的性质

### 遍历算法理解

| 遍历方式 | 访问顺序 | 应用场景 |
|----------|----------|----------|
| 前序遍历 | 根-左-右 | 复制树、表达式求值 |
| 中序遍历 | 左-根-右 | BST有序输出 |
| 后序遍历 | 左-右-根 | 删除树、计算目录大小 |
| 层序遍历 | 按层访问 | 打印树形结构 |

### 二叉搜索树的优势
- **有序性**：中序遍历得到有序序列
- **查找效率**：平均O(log n)的查找时间
- **动态性**：支持动态插入和删除

### 适用场景
- **表达式解析**：编译器语法分析
- **文件系统**：目录树结构
- **数据库索引**：B树、B+树的基础
- **决策树**：机器学习算法
- **霍夫曼编码**：数据压缩算法

### 常见问题类型

1. **树的构建**：从遍历序列重建树
2. **树的遍历**：各种遍历方式的实现
3. **树的属性**：高度、深度、节点数
4. **路径问题**：根到叶子的路径、路径和
5. **树的变换**：镜像、序列化、反序列化

## 🔗 相关算法

- **平衡树**：AVL树、红黑树、B树
- **树形DP**：树上动态规划问题
- **最近公共祖先(LCA)**：树上查询问题

## 💡 练习建议

1. 实现AVL树（自平衡二叉搜索树）
2. 从前序和中序遍历重建二叉树
3. 二叉树的锯齿形层序遍历
4. 验证二叉搜索树的有效性
5. 二叉树中的最大路径和
6. 实现序列化和反序列化二叉树
7. 完全二叉树的节点个数
8. 二叉树的右视图