# 队列实现 (Queue)

队列是先进先出(FIFO)的数据结构，在一端插入，另一端删除。

## 🔧 功能特性

- **数组队列**：基于数组的队列实现
- **链表队列**：基于链表的队列实现
- **循环队列**：固定大小的循环队列
- **双端队列**：两端都可以插入和删除
- **队列应用**：约瑟夫问题、回文检测

## 💻 核心方法

### 数组队列
```python
queue = ArrayQueue()
queue.enqueue(item)         # 入队
queue.dequeue()             # 出队
queue.front()               # 查看队头
queue.rear()                # 查看队尾
queue.is_empty()            # 判断是否为空
queue.size()                # 获取队列大小
```

### 链表队列
```python
lqueue = LinkedQueue()
lqueue.enqueue(item)        # 入队
lqueue.dequeue()            # 出队
lqueue.front()              # 查看队头
lqueue.rear()               # 查看队尾
lqueue.is_empty()           # 判断是否为空
lqueue.size()               # 获取队列大小
```

### 循环队列
```python
cqueue = CircularQueue(capacity)
cqueue.enqueue(item)        # 入队
cqueue.dequeue()            # 出队
cqueue.front_item()         # 查看队头
cqueue.rear_item()          # 查看队尾
cqueue.is_empty()           # 判断是否为空
cqueue.is_full()            # 判断是否已满
cqueue.get_size()           # 获取队列大小
```

### 双端队列
```python
deque = Deque()
deque.add_front(item)       # 前端添加
deque.add_rear(item)        # 后端添加
deque.remove_front()        # 前端移除
deque.remove_rear()         # 后端移除
deque.front()               # 查看前端
deque.rear()                # 查看后端
```

### 队列应用
```python
# 约瑟夫问题（烫手山芋游戏）
QueueApplications.hot_potato(names, num)

# 回文检测
QueueApplications.is_palindrome(string)
```

## 📈 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 入队(enqueue) | O(1) | 在队尾操作 |
| 出队(dequeue) | O(1) | 在队头操作 |
| 查看队头/队尾 | O(1) | 不移除元素 |
| 搜索 | O(n) | 需要遍历队列 |

## 🎯 运行示例

```bash
$ python queue.py

=== 基于数组的队列演示 ===
1. 入队操作:
   入队 1: [1]
   入队 2: [1, 2]
   入队 3: [1, 2, 3]
   入队 4: [1, 2, 3, 4]

2. 队头元素: 1
   队尾元素: 4

3. 出队操作:
   出队 1: [2, 3, 4]
   出队 2: [3, 4]

=== 基于链表的队列演示 ===
1. 入队操作:
   入队 A: ['A']
   入队 B: ['A', 'B']
   入队 C: ['A', 'B', 'C']

2. 队列大小: 3

3. 出队操作:
   出队 A: ['B', 'C']
   出队 B: ['C']
   出队 C: []

=== 循环队列演示 ===
1. 填满队列:
   入队 0: [0]
   入队 1: [0, 1]
   入队 2: [0, 1, 2]
   入队 3: [0, 1, 2, 3]
   入队 4: [0, 1, 2, 3, 4]

2. 部分出队后再入队:
   出队 0: [1, 2, 3, 4]
   出队 1: [2, 3, 4]
   入队 5: [2, 3, 4, 5]
   入队 6: [2, 3, 4, 5, 6]

=== 双端队列演示 ===
1. 双端添加:
   前端添加1: [1]
   后端添加2: [1, 2]
   前端添加0: [0, 1, 2]
   后端添加3: [0, 1, 2, 3]

2. 双端移除:
   前端移除0: [1, 2, 3]
   后端移除3: [1, 2]

=== 队列应用演示 ===
1. 烫手山芋游戏:
   参与者: ['Alice', 'Bob', 'Charlie', 'David', 'Eve']
   每次传递3次，获胜者: David

2. 回文检查:
   'radar' 是回文: True
   'hello' 是回文: False
   'level' 是回文: True
   'python' 是回文: False
```

## 🎓 学习要点

### 队列的特性
- **FIFO原则**：先进先出
- **双端操作**：队头出队，队尾入队
- **顺序性**：保持元素的插入顺序

### 不同队列类型对比

| 类型 | 空间效率 | 时间效率 | 适用场景 |
|------|----------|----------|----------|
| 数组队列 | 好 | 出队O(n) | 简单应用 |
| 链表队列 | 一般 | 所有操作O(1) | 频繁操作 |
| 循环队列 | 优秀 | 所有操作O(1) | 固定容量 |
| 双端队列 | 好 | 所有操作O(1) | 灵活需求 |

### 适用场景
- **任务调度**：操作系统进程调度
- **广度优先搜索(BFS)**：图和树的遍历
- **打印队列**：打印任务管理
- **键盘缓冲区**：按键输入缓存
- **进程调度**：CPU时间片分配

### 队列的经典应用

1. **约瑟夫问题**：环形淘汰游戏
2. **回文检测**：利用双端队列特性
3. **BFS遍历**：层序访问图节点
4. **滑动窗口**：固定大小的数据窗口
5. **生产者消费者**：异步处理模式

## 🔗 相关算法

- **广度优先搜索(BFS)**：使用队列实现层序遍历
- **拓扑排序**：基于队列的Kahn算法
- **滑动窗口最大值**：使用双端队列优化

## 💡 练习建议

1. 用两个栈实现队列
2. 用队列实现栈
3. 设计循环双端队列
4. 滑动窗口最大值问题
5. 队列的最大值（类似栈的最小值）
6. 实现优先队列（堆）